Index: asterixdb/asterix-algebra/src/main/java/org/apache/asterix/compiler/provider/DefaultRuleSetFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- asterixdb/asterix-algebra/src/main/java/org/apache/asterix/compiler/provider/DefaultRuleSetFactory.java	(revision ab3bddb7c949664fa427a27c80f21a1b955140ac)
+++ asterixdb/asterix-algebra/src/main/java/org/apache/asterix/compiler/provider/DefaultRuleSetFactory.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
@@ -71,6 +71,7 @@
         defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildFulltextContainsRuleCollection()));
         defaultLogicalRewrites.add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildAccessMethodRuleCollection()));
         defaultLogicalRewrites.add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildPlanCleanupRuleCollection()));
+        defaultLogicalRewrites.add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildSpatialJoinRuleCollection()));
 
         //put TXnRuleCollection!
         return defaultLogicalRewrites;
Index: asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/base/RuleCollections.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/base/RuleCollections.java	(revision ab3bddb7c949664fa427a27c80f21a1b955140ac)
+++ asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/base/RuleCollections.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
@@ -86,6 +86,7 @@
 import org.apache.asterix.optimizer.rules.SetClosedRecordConstructorsRule;
 import org.apache.asterix.optimizer.rules.SetupCommitExtensionOpRule;
 import org.apache.asterix.optimizer.rules.SimilarityCheckRule;
+import org.apache.asterix.optimizer.rules.SpatialJoinRule;
 import org.apache.asterix.optimizer.rules.SweepIllegalNonfunctionalFunctions;
 import org.apache.asterix.optimizer.rules.UnnestToDataScanRule;
 import org.apache.asterix.optimizer.rules.am.IntroduceJoinAccessMethodRule;
@@ -413,4 +414,10 @@
         prepareForJobGenRewrites.add(new FixReplicateOperatorOutputsRule());
         return prepareForJobGenRewrites;
     }
+
+    public static final List<IAlgebraicRewriteRule> buildSpatialJoinRuleCollection() {
+        List<IAlgebraicRewriteRule> spatialJoin = new LinkedList<>();
+        spatialJoin.add(new SpatialJoinRule());
+        return spatialJoin;
+    }
 }
Index: asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/SpatialJoinRule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/SpatialJoinRule.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
+++ asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/SpatialJoinRule.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
@@ -0,0 +1,195 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.asterix.optimizer.rules;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+import org.apache.asterix.om.base.ABoolean;
+import org.apache.asterix.om.base.AInt64;
+import org.apache.asterix.om.base.APoint;
+import org.apache.asterix.om.base.ARectangle;
+import org.apache.asterix.om.constants.AsterixConstantValue;
+import org.apache.asterix.om.functions.BuiltinFunctions;
+import org.apache.commons.lang3.mutable.Mutable;
+import org.apache.commons.lang3.mutable.MutableObject;
+import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;
+import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;
+import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;
+import org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;
+import org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;
+import org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;
+import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;
+import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;
+import org.apache.hyracks.algebricks.core.algebra.expressions.ConstantExpression;
+import org.apache.hyracks.algebricks.core.algebra.expressions.ScalarFunctionCallExpression;
+import org.apache.hyracks.algebricks.core.algebra.expressions.UnnestingFunctionCallExpression;
+import org.apache.hyracks.algebricks.core.algebra.expressions.VariableReferenceExpression;
+import org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;
+import org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;
+import org.apache.hyracks.algebricks.core.algebra.operators.logical.UnnestOperator;
+import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.VariableUtilities;
+import org.apache.hyracks.algebricks.core.rewriter.base.IAlgebraicRewriteRule;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class SpatialJoinRule implements IAlgebraicRewriteRule {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final int LEFT = 0;
+    private static final int RIGHT = 1;
+    private static final double MIN_X = -180.0;
+    private static final double MIN_Y = -83.0;
+    private static final double MAX_X = 180.0;
+    private static final double MAX_Y = 90.0;
+    private static final int NUM_ROWS = 50;
+    private static final int NUM_COLUMNS = 50;
+
+    @Override
+    public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context)
+            throws AlgebricksException {
+        return false;
+    }
+
+    @Override
+    public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context)
+            throws AlgebricksException {
+        // Current operator should be a join.
+        AbstractLogicalOperator op = (AbstractLogicalOperator) opRef.getValue();
+        if (op.getOperatorTag() != LogicalOperatorTag.INNERJOIN
+                && op.getOperatorTag() != LogicalOperatorTag.LEFTOUTERJOIN) {
+            return false;
+        }
+
+        // Finds SPATIAL_INTERSECT function in the join condition.
+        AbstractBinaryJoinOperator joinOp = (AbstractBinaryJoinOperator) op;
+        Mutable<ILogicalExpression> joinConditionRef = joinOp.getCondition();
+        ILogicalExpression joinCondition = joinConditionRef.getValue();
+
+        if (joinCondition.getExpressionTag() != LogicalExpressionTag.FUNCTION_CALL) {
+            return false;
+        }
+
+        AbstractFunctionCallExpression funcExpr = (AbstractFunctionCallExpression) joinCondition;
+        if (!funcExpr.getFunctionIdentifier().equals(BuiltinFunctions.SPATIAL_INTERSECT)) {
+            return false;
+        }
+
+        // Extracts spatial intersect function's arguments
+        List<Mutable<ILogicalExpression>> inputExprs = funcExpr.getArguments();
+        if (inputExprs.size() != 2) {
+            return false;
+        }
+
+        ILogicalExpression leftOperatingExpr = inputExprs.get(LEFT).getValue();
+        ILogicalExpression rightOperatingExpr = inputExprs.get(RIGHT).getValue();
+
+        // left and right expressions should be variables.
+        if (leftOperatingExpr.getExpressionTag() != LogicalExpressionTag.VARIABLE
+                || rightOperatingExpr.getExpressionTag() != LogicalExpressionTag.VARIABLE) {
+            return false;
+        }
+
+        LOGGER.info("spatial-intersect is called");
+        //        return false;
+
+        // Gets both input branches of the spatial join.
+        Mutable<ILogicalOperator> leftOp = joinOp.getInputs().get(LEFT);
+        Mutable<ILogicalOperator> rightOp = joinOp.getInputs().get(RIGHT);
+
+        // Extract left and right variable of the predicate
+        LogicalVariable inputVar0 = ((VariableReferenceExpression) leftOperatingExpr).getVariableReference();
+        LogicalVariable inputVar1 = ((VariableReferenceExpression) rightOperatingExpr).getVariableReference();
+
+        LogicalVariable leftInputVar;
+        LogicalVariable rightInputVar;
+        Collection<LogicalVariable> liveVars = new HashSet<>();
+        VariableUtilities.getLiveVariables(leftOp.getValue(), liveVars);
+        if (liveVars.contains(inputVar0)) {
+            leftInputVar = inputVar0;
+            rightInputVar = inputVar1;
+        } else {
+            leftInputVar = inputVar1;
+            rightInputVar = inputVar0;
+        }
+
+        // Inject unnest operator to the left and right branch of the join operator
+        LogicalVariable leftTileIdVar = injectUnnestOperator(context, leftOp, leftInputVar);
+        LogicalVariable rightTileIdVar = injectUnnestOperator(context, rightOp, rightInputVar);
+
+        // Compute reference tile ID
+        //        ScalarFunctionCallExpression referenceTileId = new ScalarFunctionCallExpression(BuiltinFunctions.getBuiltinFunctionInfo(BuiltinFunctions.REFERENCE_TILE),
+        //                new MutableObject<>(new VariableReferenceExpression(leftInputVar)),
+        //                new MutableObject<>(new VariableReferenceExpression(rightInputVar)),
+        //                new MutableObject<>(new ConstantExpression(new AsterixConstantValue(
+        //                        new ARectangle(new APoint(MIN_X, MIN_Y), new APoint(MAX_X, MAX_Y))))),
+        //                new MutableObject<>(new ConstantExpression(new AsterixConstantValue(new AInt64(NUM_ROWS)))),
+        //                new MutableObject<>(
+        //                        new ConstantExpression(new AsterixConstantValue(new AInt64(NUM_COLUMNS)))));
+
+        // Update the join conditions with the tile Id equality condition
+        //        ScalarFunctionCallExpression tileIdEquiJoinCondition =
+        //                new ScalarFunctionCallExpression(BuiltinFunctions.getBuiltinFunctionInfo(BuiltinFunctions.EQ),
+        //                        new MutableObject<>(new VariableReferenceExpression(leftTileIdVar)),
+        //                        new MutableObject<>(new VariableReferenceExpression(rightTileIdVar)));
+        //        ScalarFunctionCallExpression referenceIdEquiJoinCondition =
+        //                new ScalarFunctionCallExpression(BuiltinFunctions.getBuiltinFunctionInfo(BuiltinFunctions.EQ),
+        //                        new MutableObject<>(new VariableReferenceExpression(leftTileIdVar)),
+        //                        new MutableObject<>(referenceTileId));
+        //        ScalarFunctionCallExpression spatialJoinCondition = new ScalarFunctionCallExpression(
+        //                BuiltinFunctions.getBuiltinFunctionInfo(BuiltinFunctions.SPATIAL_INTERSECT),
+        //                new MutableObject<>(new VariableReferenceExpression(leftInputVar)),
+        //                new MutableObject<>(new VariableReferenceExpression(rightInputVar)));
+        ScalarFunctionCallExpression updatedJoinCondition =
+                new ScalarFunctionCallExpression(BuiltinFunctions.getBuiltinFunctionInfo(BuiltinFunctions.AND),
+                        new MutableObject<>(new ConstantExpression(new AsterixConstantValue(ABoolean.valueOf(true)))),
+                        new MutableObject<>(new ConstantExpression(new AsterixConstantValue(ABoolean.valueOf(true))))
+                //                        new MutableObject<>(tileIdEquiJoinCondition)
+                //                        new MutableObject<>(referenceIdEquiJoinCondition),
+                //                        new MutableObject<>(spatialJoinCondition)
+                );
+        joinConditionRef.setValue(updatedJoinCondition);
+
+        return true;
+    }
+
+    private LogicalVariable injectUnnestOperator(IOptimizationContext context, Mutable<ILogicalOperator> sideOp,
+            LogicalVariable inputVar) {
+        LogicalVariable sideVar = context.newVar();
+        VariableReferenceExpression sideInputVar = new VariableReferenceExpression(inputVar);
+        UnnestOperator sideUnnestOp = new UnnestOperator(sideVar,
+                new MutableObject<>(new UnnestingFunctionCallExpression(
+                        BuiltinFunctions.getBuiltinFunctionInfo(BuiltinFunctions.SPATIAL_TILE),
+                        new MutableObject<>(sideInputVar),
+                        new MutableObject<>(new ConstantExpression(new AsterixConstantValue(
+                                new ARectangle(new APoint(MIN_X, MIN_Y), new APoint(MAX_X, MAX_Y))))),
+                        new MutableObject<>(new ConstantExpression(new AsterixConstantValue(new AInt64(NUM_ROWS)))),
+                        new MutableObject<>(
+                                new ConstantExpression(new AsterixConstantValue(new AInt64(NUM_COLUMNS)))))));
+        sideUnnestOp.getInputs().add(new MutableObject<>(sideOp.getValue()));
+        sideOp.setValue(sideUnnestOp);
+        try {
+            context.computeAndSetTypeEnvironmentForOperator(sideUnnestOp);
+        } catch (AlgebricksException e) {
+            e.printStackTrace();
+        }
+        return sideVar;
+    }
+}
Index: asterixdb/asterix-om/src/main/java/org/apache/asterix/om/functions/BuiltinFunctions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- asterixdb/asterix-om/src/main/java/org/apache/asterix/om/functions/BuiltinFunctions.java	(revision ab3bddb7c949664fa427a27c80f21a1b955140ac)
+++ asterixdb/asterix-om/src/main/java/org/apache/asterix/om/functions/BuiltinFunctions.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
@@ -1031,6 +1031,8 @@
             new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "subset-collection", 3);
 
     public static final FunctionIdentifier RANGE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "range", 2);
+    public static final FunctionIdentifier SPATIAL_TILE =
+            new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "spatial-tile", 4);
 
     // fuzzy functions
     public static final FunctionIdentifier FUZZY_EQ =
@@ -1233,6 +1235,8 @@
     public static final FunctionIdentifier CAST_TYPE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "cast", 1);
     public static final FunctionIdentifier CAST_TYPE_LAX =
             new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "cast-lax", 1);
+    public static final FunctionIdentifier REFERENCE_TILE =
+            new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "reference-tile", 5);
 
     public static final FunctionIdentifier CREATE_UUID =
             new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "create-uuid", 0);
@@ -2136,6 +2140,9 @@
         addFunction(GET_CIRCLE_RADIUS_ACCESSOR, ADoubleTypeComputer.INSTANCE, true);
         addFunction(GET_CIRCLE_CENTER_ACCESSOR, APointTypeComputer.INSTANCE, true);
         addFunction(GET_POINTS_LINE_RECTANGLE_POLYGON_ACCESSOR, OrderedListOfAPointTypeComputer.INSTANCE, true);
+        //        addFunction(SPATIAL_TILE, OrderedListOfAInt32TypeComputer.INSTANCE, true);
+        addFunction(SPATIAL_TILE, AInt32TypeComputer.INSTANCE, true);
+        addFunction(REFERENCE_TILE, AInt32TypeComputer.INSTANCE, true);
 
         //geo functions
         addFunction(ST_AREA, ADoubleTypeComputer.INSTANCE, true);
@@ -3060,6 +3067,7 @@
         addUnnestFun(RANGE, true);
         addUnnestFun(SCAN_COLLECTION, false);
         addUnnestFun(SUBSET_COLLECTION, false);
+        addUnnestFun(SPATIAL_TILE, false);
     }
 
     public enum DataSourceFunctionProperty implements BuiltinFunctionProperty {
Index: asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/evaluators/functions/ReferenceTileDescriptor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/evaluators/functions/ReferenceTileDescriptor.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
+++ asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/evaluators/functions/ReferenceTileDescriptor.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
@@ -0,0 +1,186 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.asterix.runtime.evaluators.functions;
+
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.asterix.dataflow.data.nontagged.Coordinate;
+import org.apache.asterix.dataflow.data.nontagged.serde.ADoubleSerializerDeserializer;
+import org.apache.asterix.dataflow.data.nontagged.serde.AInt64SerializerDeserializer;
+import org.apache.asterix.dataflow.data.nontagged.serde.ARectangleSerializerDeserializer;
+import org.apache.asterix.om.functions.BuiltinFunctions;
+import org.apache.asterix.om.functions.IFunctionDescriptor;
+import org.apache.asterix.om.functions.IFunctionDescriptorFactory;
+import org.apache.asterix.om.types.ATypeTag;
+import org.apache.asterix.om.types.EnumDeserializer;
+import org.apache.asterix.runtime.evaluators.base.AbstractScalarFunctionDynamicDescriptor;
+import org.apache.asterix.runtime.exceptions.TypeMismatchException;
+import org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;
+import org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;
+import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;
+import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;
+import org.apache.hyracks.api.exceptions.HyracksDataException;
+import org.apache.hyracks.data.std.api.IPointable;
+import org.apache.hyracks.data.std.primitive.VoidPointable;
+import org.apache.hyracks.data.std.util.ArrayBackedValueStorage;
+import org.apache.hyracks.dataflow.common.data.accessors.IFrameTupleReference;
+
+public class ReferenceTileDescriptor extends AbstractScalarFunctionDynamicDescriptor {
+    private static final long serialVersionUID = 1L;
+
+    public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() {
+        @Override
+        public IFunctionDescriptor createFunctionDescriptor() {
+            return new ReferenceTileDescriptor();
+        }
+    };
+
+    @Override
+    public FunctionIdentifier getIdentifier() {
+        return BuiltinFunctions.REFERENCE_TILE;
+    }
+
+    @Override
+    public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) {
+        return new IScalarEvaluatorFactory() {
+            private static final long serialVersionUID = 1L;
+
+            @Override
+            public IScalarEvaluator createScalarEvaluator(final IEvaluatorContext ctx) throws HyracksDataException {
+                return new IScalarEvaluator() {
+
+                    private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage();
+                    private final DataOutput out = resultStorage.getDataOutput();
+                    private final IPointable inputArg0 = new VoidPointable();
+                    private final IPointable inputArg1 = new VoidPointable();
+                    private final IPointable inputArg2 = new VoidPointable();
+                    private final IPointable inputArg3 = new VoidPointable();
+                    private final IPointable inputArg4 = new VoidPointable();
+                    private final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx);
+                    private final IScalarEvaluator eval1 = args[1].createScalarEvaluator(ctx);
+                    private final IScalarEvaluator eval2 = args[2].createScalarEvaluator(ctx);
+                    private final IScalarEvaluator eval3 = args[3].createScalarEvaluator(ctx);
+                    private final IScalarEvaluator eval4 = args[4].createScalarEvaluator(ctx);
+
+                    @Override
+                    public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException {
+                        resultStorage.reset();
+
+                        eval0.evaluate(tuple, inputArg0);
+                        eval1.evaluate(tuple, inputArg1);
+                        eval2.evaluate(tuple, inputArg2);
+                        eval3.evaluate(tuple, inputArg3);
+                        eval4.evaluate(tuple, inputArg4);
+
+                        byte[] bytes0 = inputArg0.getByteArray();
+                        byte[] bytes1 = inputArg1.getByteArray();
+                        byte[] bytes2 = inputArg2.getByteArray();
+                        byte[] bytes3 = inputArg3.getByteArray();
+                        byte[] bytes4 = inputArg4.getByteArray();
+                        int offset0 = inputArg0.getStartOffset();
+                        int offset1 = inputArg1.getStartOffset();
+                        int offset2 = inputArg2.getStartOffset();
+                        int offset3 = inputArg3.getStartOffset();
+                        int offset4 = inputArg4.getStartOffset();
+
+                        ATypeTag tag0 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes0[offset0]);
+                        ATypeTag tag1 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes1[offset1]);
+                        ATypeTag tag2 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes2[offset2]);
+                        ATypeTag tag3 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes3[offset3]);
+                        ATypeTag tag4 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes4[offset4]);
+
+                        if ((tag0 == ATypeTag.RECTANGLE) && (tag1 == ATypeTag.RECTANGLE) && (tag2 == ATypeTag.RECTANGLE)
+                                && (tag3 == ATypeTag.BIGINT) && (tag4 == ATypeTag.BIGINT)) {
+                            double ax1 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.X));
+                            double ay1 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.Y));
+
+                            //                            double ax2 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                            //                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.X));
+                            //                            double ay2 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                            //                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.Y));
+
+                            double bx1 = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.X));
+                            double by1 = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.Y));
+
+                            //                            double bx2 = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                            //                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.X));
+                            //                            double by2 = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                            //                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.Y));
+
+                            double minX = ADoubleSerializerDeserializer.getDouble(bytes2, offset2 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.X));
+                            double minY = ADoubleSerializerDeserializer.getDouble(bytes2, offset2 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.Y));
+
+                            double maxX = ADoubleSerializerDeserializer.getDouble(bytes2, offset2 + 1
+                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.X));
+                            double maxY = ADoubleSerializerDeserializer.getDouble(bytes2, offset2 + 1
+                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.Y));
+
+                            int rows = (int) AInt64SerializerDeserializer.getLong(bytes3, offset3 + 1);
+                            int columns = (int) AInt64SerializerDeserializer.getLong(bytes4, offset4 + 1);
+
+                            // Compute the reference point
+                            double x = Math.max(ax1, bx1);
+                            double y = Math.max(ay1, by1);
+
+                            // Compute the tile ID of the reference point
+                            int row = (int) Math.floor((y - minY) * rows / (maxY - minY));
+                            int col = (int) Math.floor((x - minX) * columns / (maxX - minX));
+                            int tileId = row * columns + col;
+                            try {
+                                out.writeByte(ATypeTag.SERIALIZED_INT32_TYPE_TAG);
+                                out.writeInt(tileId);
+                            } catch (IOException e) {
+                                e.printStackTrace();
+                            }
+                            result.set(resultStorage);
+                        } else {
+                            if (tag0 != ATypeTag.RECTANGLE) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes0[offset0],
+                                        ATypeTag.SERIALIZED_RECTANGLE_TYPE_TAG);
+                            }
+                            if (tag1 != ATypeTag.RECTANGLE) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes1[offset1],
+                                        ATypeTag.SERIALIZED_RECTANGLE_TYPE_TAG);
+                            }
+                            if (tag2 != ATypeTag.RECTANGLE) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes2[offset2],
+                                        ATypeTag.SERIALIZED_RECTANGLE_TYPE_TAG);
+                            }
+                            if (tag3 != ATypeTag.BIGINT) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes3[offset3],
+                                        ATypeTag.SERIALIZED_INT64_TYPE_TAG);
+                            }
+                            if (tag4 != ATypeTag.BIGINT) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes4[offset4],
+                                        ATypeTag.SERIALIZED_INT64_TYPE_TAG);
+                            }
+                        }
+                    }
+                };
+            }
+        };
+    }
+}
Index: asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/functions/FunctionCollection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/functions/FunctionCollection.java	(revision ab3bddb7c949664fa427a27c80f21a1b955140ac)
+++ asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/functions/FunctionCollection.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
@@ -411,6 +411,7 @@
 import org.apache.asterix.runtime.evaluators.functions.OrDescriptor;
 import org.apache.asterix.runtime.evaluators.functions.RandomDescriptor;
 import org.apache.asterix.runtime.evaluators.functions.RandomWithSeedDescriptor;
+import org.apache.asterix.runtime.evaluators.functions.ReferenceTileDescriptor;
 import org.apache.asterix.runtime.evaluators.functions.SleepDescriptor;
 import org.apache.asterix.runtime.evaluators.functions.SpatialAreaDescriptor;
 import org.apache.asterix.runtime.evaluators.functions.SpatialCellDescriptor;
@@ -575,6 +576,7 @@
 import org.apache.asterix.runtime.runningaggregates.std.WinPartitionLenRunningAggregateDescriptor;
 import org.apache.asterix.runtime.unnestingfunctions.std.RangeDescriptor;
 import org.apache.asterix.runtime.unnestingfunctions.std.ScanCollectionDescriptor;
+import org.apache.asterix.runtime.unnestingfunctions.std.SpatialTileDescriptor;
 import org.apache.asterix.runtime.unnestingfunctions.std.SubsetCollectionDescriptor;
 
 /**
@@ -626,6 +628,7 @@
         fc.add(ScanCollectionDescriptor.FACTORY);
         fc.add(RangeDescriptor.FACTORY);
         fc.add(SubsetCollectionDescriptor.FACTORY);
+        fc.add(SpatialTileDescriptor.FACTORY);
 
         // aggregate functions
         fc.add(ListifyAggregateDescriptor.FACTORY);
@@ -1079,6 +1082,7 @@
         fc.add(CircleRadiusAccessor.FACTORY);
         fc.add(CircleCenterAccessor.FACTORY);
         fc.add(LineRectanglePolygonAccessor.FACTORY);
+        fc.add(ReferenceTileDescriptor.FACTORY);
 
         // full-text function
         fc.add(FullTextContainsDescriptor.FACTORY);
Index: asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/unnestingfunctions/std/SpatialTileDescriptor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/unnestingfunctions/std/SpatialTileDescriptor.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
+++ asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/unnestingfunctions/std/SpatialTileDescriptor.java	(revision c94e635f86bccbb71b2e0110a0b363543fe02897)
@@ -0,0 +1,197 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.asterix.runtime.unnestingfunctions.std;
+
+import java.io.DataOutput;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.asterix.dataflow.data.nontagged.Coordinate;
+import org.apache.asterix.dataflow.data.nontagged.serde.ADoubleSerializerDeserializer;
+import org.apache.asterix.dataflow.data.nontagged.serde.AInt64SerializerDeserializer;
+import org.apache.asterix.dataflow.data.nontagged.serde.ARectangleSerializerDeserializer;
+import org.apache.asterix.formats.nontagged.SerializerDeserializerProvider;
+import org.apache.asterix.om.base.AMutableInt32;
+import org.apache.asterix.om.functions.BuiltinFunctions;
+import org.apache.asterix.om.functions.IFunctionDescriptor;
+import org.apache.asterix.om.functions.IFunctionDescriptorFactory;
+import org.apache.asterix.om.types.ATypeTag;
+import org.apache.asterix.om.types.BuiltinType;
+import org.apache.asterix.om.types.EnumDeserializer;
+import org.apache.asterix.runtime.exceptions.TypeMismatchException;
+import org.apache.asterix.runtime.unnestingfunctions.base.AbstractUnnestingFunctionDynamicDescriptor;
+import org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;
+import org.apache.hyracks.algebricks.runtime.base.IEvaluatorContext;
+import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;
+import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;
+import org.apache.hyracks.algebricks.runtime.base.IUnnestingEvaluator;
+import org.apache.hyracks.algebricks.runtime.base.IUnnestingEvaluatorFactory;
+import org.apache.hyracks.api.dataflow.value.ISerializerDeserializer;
+import org.apache.hyracks.api.exceptions.HyracksDataException;
+import org.apache.hyracks.data.std.api.IPointable;
+import org.apache.hyracks.data.std.primitive.VoidPointable;
+import org.apache.hyracks.data.std.util.ArrayBackedValueStorage;
+import org.apache.hyracks.dataflow.common.data.accessors.IFrameTupleReference;
+
+public class SpatialTileDescriptor extends AbstractUnnestingFunctionDynamicDescriptor {
+    private static final long serialVersionUID = 1L;
+
+    public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() {
+        @Override
+        public IFunctionDescriptor createFunctionDescriptor() {
+            return new SpatialTileDescriptor();
+        }
+    };
+
+    @Override
+    public FunctionIdentifier getIdentifier() {
+        return BuiltinFunctions.SPATIAL_TILE;
+    }
+
+    @Override
+    public IUnnestingEvaluatorFactory createUnnestingEvaluatorFactory(final IScalarEvaluatorFactory[] args) {
+        return new IUnnestingEvaluatorFactory() {
+
+            private static final long serialVersionUID = 1L;
+
+            @Override
+            public IUnnestingEvaluator createUnnestingEvaluator(final IEvaluatorContext ctx)
+                    throws HyracksDataException {
+                return new IUnnestingEvaluator() {
+                    private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage();
+                    private List<Integer> tileValues = new ArrayList<>();
+                    private final DataOutput out = resultStorage.getDataOutput();
+                    private final IPointable inputArg0 = new VoidPointable();
+                    private final IPointable inputArg1 = new VoidPointable();
+                    private final IPointable inputArg2 = new VoidPointable();
+                    private final IPointable inputArg3 = new VoidPointable();
+                    private final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx);
+                    private final IScalarEvaluator eval1 = args[1].createScalarEvaluator(ctx);
+                    private final IScalarEvaluator eval2 = args[2].createScalarEvaluator(ctx);
+                    private final IScalarEvaluator eval3 = args[3].createScalarEvaluator(ctx);
+
+                    private AMutableInt32 aInt32 = new AMutableInt32(0);
+                    int pos;
+
+                    @SuppressWarnings("unchecked")
+                    private ISerializerDeserializer intSerde =
+                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT32);
+
+                    @Override
+                    public void init(IFrameTupleReference tuple) throws HyracksDataException {
+                        eval0.evaluate(tuple, inputArg0);
+                        eval1.evaluate(tuple, inputArg1);
+                        eval2.evaluate(tuple, inputArg2);
+                        eval3.evaluate(tuple, inputArg3);
+
+                        byte[] bytes0 = inputArg0.getByteArray();
+                        byte[] bytes1 = inputArg1.getByteArray();
+                        byte[] bytes2 = inputArg2.getByteArray();
+                        byte[] bytes3 = inputArg3.getByteArray();
+                        int offset0 = inputArg0.getStartOffset();
+                        int offset1 = inputArg1.getStartOffset();
+                        int offset2 = inputArg2.getStartOffset();
+                        int offset3 = inputArg3.getStartOffset();
+
+                        ATypeTag tag0 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes0[offset0]);
+                        ATypeTag tag1 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes1[offset1]);
+                        ATypeTag tag2 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes2[offset2]);
+                        ATypeTag tag3 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes3[offset3]);
+
+                        if ((tag0 == ATypeTag.RECTANGLE) && (tag1 == ATypeTag.RECTANGLE) && (tag2 == ATypeTag.BIGINT)
+                                && (tag3 == ATypeTag.BIGINT)) {
+                            double x1 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.X));
+                            double y1 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.Y));
+
+                            double x2 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.X));
+                            double y2 = ADoubleSerializerDeserializer.getDouble(bytes0, offset0 + 1
+                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.Y));
+
+                            double minX = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.X));
+                            double minY = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                                    + ARectangleSerializerDeserializer.getBottomLeftCoordinateOffset(Coordinate.Y));
+
+                            double maxX = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.X));
+                            double maxY = ADoubleSerializerDeserializer.getDouble(bytes1, offset1 + 1
+                                    + ARectangleSerializerDeserializer.getUpperRightCoordinateOffset(Coordinate.Y));
+
+                            int rows = (int) AInt64SerializerDeserializer.getLong(bytes2, offset2 + 1);
+                            int columns = (int) AInt64SerializerDeserializer.getLong(bytes3, offset3 + 1);
+
+                            int row1 = (int) Math.floor((y1 - minY) * rows / (maxY - minY));
+                            int col1 = (int) Math.floor((x1 - minX) * columns / (maxX - minX));
+                            int row2 = (int) Math.floor((y2 - minY) * rows / (maxY - minY));
+                            int col2 = (int) Math.floor((x2 - minX) * columns / (maxX - minX));
+
+                            int minRow = Math.min(row1, row2);
+                            int maxRow = Math.max(row1, row2);
+                            int minCol = Math.min(col1, col2);
+                            int maxCol = Math.max(col1, col2);
+
+                            tileValues.clear();
+                            for (int i = minRow; i <= maxRow; i++) {
+                                for (int j = minCol; j <= maxCol; j++) {
+                                    int tileId = i * columns + j;
+                                    tileValues.add(tileId);
+                                }
+                            }
+                            pos = 0;
+                        } else {
+                            if (tag0 != ATypeTag.RECTANGLE) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes0[offset0],
+                                        ATypeTag.SERIALIZED_RECTANGLE_TYPE_TAG);
+                            }
+                            if (tag1 != ATypeTag.RECTANGLE) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes1[offset1],
+                                        ATypeTag.SERIALIZED_RECTANGLE_TYPE_TAG);
+                            }
+                            if (tag2 != ATypeTag.BIGINT) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes2[offset2],
+                                        ATypeTag.SERIALIZED_INT64_TYPE_TAG);
+                            }
+                            if (tag3 != ATypeTag.BIGINT) {
+                                throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes3[offset3],
+                                        ATypeTag.SERIALIZED_INT64_TYPE_TAG);
+                            }
+                        }
+                    }
+
+                    @SuppressWarnings("unchecked")
+                    @Override
+                    public boolean step(IPointable result) throws HyracksDataException {
+                        if (pos < tileValues.size()) {
+                            aInt32.setValue(tileValues.get(pos));
+                            resultStorage.reset();
+                            intSerde.serialize(aInt32, resultStorage.getDataOutput());
+                            result.set(resultStorage);
+                            ++pos;
+                            return true;
+                        }
+                        return false;
+                    }
+                };
+            }
+        };
+    }
+}
